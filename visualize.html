<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pattern Language — Knowledge Graph</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=DM+Mono:wght@400&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg:         #0c0a08;
    --surface:    #100e0b;
    --border:     rgba(200,185,155,0.09);
    --border-mid: rgba(200,185,155,0.16);
    --text:       #c4baa8;
    --text-dim:   #66594a;
    --text-faint: #38312a;
    --accent:     #a07828;
    --accent-dim: rgba(160,120,40,0.16);
    --link-req:   #7a2e1e;
    --link-enh:   #2e5a3a;
    --danger:     #883018;
    --noted:      #2e5228;
  }

  body {
    font-family: 'Cormorant Garamond', Georgia, serif;
    background: var(--bg);
    color: var(--text);
    display: flex;
    height: 100vh;
    overflow: hidden;
  }

  /* ── Graph canvas ── */
  #graph-area { flex: 1; position: relative; overflow: hidden; }
  svg { width: 100%; height: 100%; }

  /* ── Links ── */
  .link { stroke-opacity: 0.45; stroke-width: 1; fill: none; }
  .link.required     { stroke: #7a2e1e; }
  .link.enhanced_by  { stroke: #2a5030; }
  .link.incompatible { stroke: #5a4818; stroke-dasharray: 5 4; }
  .link-arrow { fill-opacity: 0.55; }

  /* ── Nodes ── */
  .node-loaded circle { stroke-width: 1; cursor: pointer; transition: stroke-opacity 0.2s; }
  .node-loaded.active circle:not(.strain-ring) { stroke-width: 1.5; stroke-opacity: 1; }
  .node-loaded circle:not(.strain-ring):hover  { stroke-opacity: 0.85; }
  .node-external circle { cursor: pointer; opacity: 0.3; }
  .node-external circle:hover { opacity: 0.6; }

  .label-loaded {
    font-family: 'DM Mono', monospace;
    font-size: 8px;
    fill: var(--text);
    fill-opacity: 0.55;
    pointer-events: none;
    text-anchor: middle;
  }
  .label-loaded .num { font-size: 10px; fill-opacity: 0.75; }
  .label-external {
    font-family: 'DM Mono', monospace;
    font-size: 7px;
    fill: var(--text-dim);
    pointer-events: none;
    text-anchor: middle;
  }

  /* ── Controls ── */
  #controls {
    position: absolute; top: 20px; left: 20px;
    display: flex; flex-direction: column; gap: 6px; z-index: 10;
  }
  .ctrl-group {
    background: rgba(12,10,8,0.78);
    border: 1px solid var(--border);
    border-radius: 2px;
    padding: 9px 13px;
    backdrop-filter: blur(14px);
  }
  .ctrl-group h4 {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--text-dim); margin-bottom: 8px;
  }
  .ctrl-row {
    display: flex; align-items: center; gap: 8px;
    font-size: 12px; color: var(--text-dim);
    margin-bottom: 4px; cursor: pointer; user-select: none;
  }
  .ctrl-row:last-child { margin-bottom: 0; }
  .swatch { width: 18px; height: 1px; flex-shrink: 0; opacity: 0.6; }
  .toggle-btn {
    background: transparent; border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text-dim);
    font-family: 'Cormorant Garamond', serif;
    font-size: 12px; padding: 3px 0; cursor: pointer;
    width: 100%; text-align: left;
    transition: color 0.2s, border-color 0.2s;
    margin-bottom: 4px;
  }
  .toggle-btn:last-child { margin-bottom: 0; border-bottom: none; }
  .toggle-btn:hover { color: var(--text); }
  .toggle-btn.active { color: var(--accent); border-bottom-color: var(--accent-dim); }

  /* ── Panel ── */
  #panel {
    width: 380px; min-width: 340px;
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex; flex-direction: column;
    overflow: hidden; transition: width 0.3s;
  }
  #panel.hidden { width: 0; min-width: 0; border: none; }
  #panel-header {
    padding: 26px 26px 18px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  #panel-num {
    font-family: 'DM Mono', monospace;
    font-size: 8px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--text-dim); margin-bottom: 6px;
  }
  #panel-name {
    font-size: 24px; font-weight: 400;
    color: var(--text); margin-bottom: 10px;
    line-height: 1.2; letter-spacing: 0.01em;
  }
  #panel-confidence {
    font-family: 'DM Mono', monospace;
    font-size: 8px; color: var(--text-dim); letter-spacing: 0.12em;
  }
  #panel-body { flex: 1; overflow-y: auto; padding: 0 0 36px; }
  #panel-body::-webkit-scrollbar { width: 2px; }
  #panel-body::-webkit-scrollbar-track { background: transparent; }
  #panel-body::-webkit-scrollbar-thumb { background: var(--border-mid); }

  .section { padding: 20px 26px 0; }
  .section-title {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--accent); opacity: 0.65;
    border-bottom: 1px solid var(--border);
    padding-bottom: 7px; margin-bottom: 14px;
  }

  /* Verbatim */
  .verbatim-block {
    font-style: italic; font-size: 13px;
    color: var(--text-dim); line-height: 1.75;
    border-left: 1px solid var(--border-mid);
    padding: 6px 14px; margin-bottom: 10px;
  }
  .verbatim-label {
    font-family: 'DM Mono', monospace;
    font-size: 7px; text-transform: uppercase;
    color: var(--text-faint); letter-spacing: 0.15em;
    margin-bottom: 5px; font-style: normal;
  }

  /* Force cards */
  .force-card { padding: 10px 0; border-bottom: 1px solid var(--border); }
  .force-card:last-child { border-bottom: none; }
  .force-header { display: flex; align-items: baseline; gap: 9px; margin-bottom: 7px; }
  .force-type-badge {
    font-family: 'DM Mono', monospace;
    font-size: 7px; padding: 1px 5px; border-radius: 1px;
    text-transform: uppercase; letter-spacing: 0.1em;
    flex-shrink: 0; opacity: 0.6;
    border: 1px solid currentColor; background: transparent;
  }
  .force-name { font-size: 14px; font-weight: 600; color: var(--text); line-height: 1.3; }
  .poles { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 7px; }
  .pole { font-size: 11px; color: var(--text-dim); line-height: 1.55; }
  .pole-a::before { content: "A  "; font-family: 'DM Mono', monospace; font-size: 7px; color: var(--text-faint); }
  .pole-b::before { content: "B  "; font-family: 'DM Mono', monospace; font-size: 7px; color: var(--text-faint); }

  /* Rule rows */
  .rule-row { padding: 9px 0; border-bottom: 1px solid var(--border); }
  .rule-row:last-child { border-bottom: none; }
  .rule-header { display: flex; align-items: center; gap: 5px; margin-bottom: 3px; flex-wrap: wrap; }
  .rule-badge {
    font-family: 'DM Mono', monospace;
    font-size: 7px; padding: 1px 4px; border-radius: 1px;
    flex-shrink: 0; letter-spacing: 0.06em; opacity: 0.55;
  }
  .rule-badge.hard { color: #9a4030; border: 1px solid #4a2018; }
  .rule-badge.soft { color: #4a6080; border: 1px solid #1a2a3a; }
  .rule-badge.inv  { color: #7a5080; border: 1px solid #3a2042; }
  .rule-badge.adp  { color: #3a6038; border: 1px solid #182e16; }
  .rule-metric { font-size: 13px; color: var(--text); }
  .rule-value  { font-family: 'DM Mono', monospace; font-size: 10px; color: var(--accent); margin-top: 2px; opacity: 0.8; }
  .rule-source { font-size: 10px; font-style: italic; color: var(--text-faint); margin-top: 4px; line-height: 1.45; }

  /* Failure rows */
  .failure-row { padding: 9px 0; border-bottom: 1px solid var(--border); }
  .failure-row:last-child { border-bottom: none; }
  .failure-desc { font-size: 12px; color: var(--text-dim); line-height: 1.65; margin-bottom: 5px; }
  .failure-sym  { font-size: 10px; font-style: italic; color: var(--text-faint); line-height: 1.45; }
  .failure-sym::before { content: "▸  "; color: var(--danger); opacity: 0.5; }

  /* ── Legend ── */
  #legend {
    position: absolute; bottom: 20px; left: 20px;
    background: rgba(12,10,8,0.78);
    border: 1px solid var(--border); border-radius: 2px;
    padding: 9px 13px; z-index: 10; backdrop-filter: blur(14px);
  }
  #legend h4 {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--text-dim); margin-bottom: 8px;
  }
  .legend-row {
    display: flex; align-items: center; gap: 9px;
    margin-bottom: 4px; color: var(--text-dim); font-size: 11px;
  }
  .legend-row:last-child { margin-bottom: 0; }
  .legend-line { width: 20px; height: 1px; flex-shrink: 0; }

  #hint {
    position: absolute; bottom: 20px; right: 20px;
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.1em;
    color: var(--text-faint); z-index: 10;
  }

  /* ── Strain rings ── */
  .strain-ring {
    fill: none; stroke-width: 1; pointer-events: none;
    transform-box: fill-box; transform-origin: center;
  }
  .strain-none { stroke: none; }
  .strain-low {
    stroke: #806018; stroke-opacity: 0.3; stroke-dasharray: 12 7;
    animation: strain-spin 20s linear infinite;
  }
  .strain-mid {
    stroke: #7a3018; stroke-opacity: 0.45; stroke-dasharray: 8 5;
    animation: strain-spin 10s linear infinite, strain-pulse 4s ease-in-out infinite;
  }
  .strain-high {
    stroke: #882018; stroke-opacity: 0.6; stroke-dasharray: 5 4;
    animation: strain-spin 5s linear infinite, strain-pulse 2.5s ease-in-out infinite;
  }
  @keyframes strain-spin {
    from { transform: rotate(0deg); }
    to   { transform: rotate(360deg); }
  }
  @keyframes strain-pulse {
    0%, 100% { stroke-opacity: 0.6; }
    50%       { stroke-opacity: 0.06; }
  }

  /* ── Tension panel section ── */
  .tension-section { padding: 18px 26px 0; }
  .tension-section-title {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--danger); opacity: 0.65;
    border-bottom: 1px solid rgba(136,48,24,0.18);
    padding-bottom: 7px; margin-bottom: 0;
  }
  .tension-item { padding: 11px 0; border-bottom: 1px solid var(--border); }
  .tension-item:last-child { border-bottom: none; }
  .tension-header { display: flex; align-items: flex-start; gap: 7px; margin-bottom: 4px; }
  .tension-badge {
    font-family: 'DM Mono', monospace;
    font-size: 7px; padding: 1px 5px; border-radius: 1px;
    flex-shrink: 0; margin-top: 3px;
    text-transform: uppercase; letter-spacing: 0.1em;
    border: 1px solid currentColor;
  }
  .tension-open  { color: #8a3818; }
  .tension-noted { color: #3a5828; }
  .tension-target-name { font-size: 12px; color: var(--text-dim); line-height: 1.35; }
  .tension-item.tension-acked .tension-target-name { color: #486030; }
  .tension-note {
    font-size: 11px; font-style: italic;
    color: var(--text-faint); line-height: 1.6; margin-bottom: 9px;
  }
  .tension-annotation {
    background: transparent;
    border: none; border-bottom: 1px solid var(--border);
    color: var(--text-dim);
    font-family: 'Cormorant Garamond', serif;
    font-size: 13px; line-height: 1.6;
    padding: 5px 0; resize: none; min-height: 48px;
    width: 100%; box-sizing: border-box;
  }
  .tension-annotation:focus { outline: none; border-bottom-color: var(--accent); }
  .tension-annotation::placeholder { color: var(--text-faint); font-style: italic; }
  .tension-annotation-wrap { display: flex; flex-direction: column; gap: 6px; }
  .tension-save-btn {
    align-self: flex-end; background: transparent; border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text-dim); cursor: pointer;
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.12em;
    padding: 3px 0; transition: color 0.15s, border-color 0.15s;
  }
  .tension-save-btn:hover { color: var(--accent); border-bottom-color: var(--accent-dim); }
  .tension-ann-display {
    font-size: 12px; font-style: italic; color: #486030;
    line-height: 1.55; margin-top: 3px;
  }
  .tension-edit-btn {
    background: none; border: none; color: var(--text-faint);
    cursor: pointer; font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.1em;
    padding: 3px 0; opacity: 0.7;
  }
  .tension-edit-btn:hover { color: var(--text-dim); opacity: 1; }

  /* ── Compass overlay ── */
  #compass-wrap {
    display: none; position: absolute; top: 20px; right: 20px;
    z-index: 10; pointer-events: none;
    background: rgba(12,10,8,0.78);
    border: 1px solid var(--border); border-radius: 2px;
    padding: 10px 14px; backdrop-filter: blur(14px); text-align: center;
  }
  #compass-wrap h4 {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em; text-transform: uppercase;
    color: var(--text-dim); margin-bottom: 8px;
  }
  .compass-legend {
    display: grid; grid-template-columns: 1fr 1fr; gap: 3px 10px;
    font-family: 'DM Mono', monospace; font-size: 7px;
    margin-top: 8px; text-align: left; color: var(--text-dim);
  }

  /* ── Privacy overlay bar ── */
  #privacy-wrap {
    display: none; position: absolute; bottom: 52px; left: 50%;
    transform: translateX(-50%); z-index: 10; pointer-events: none;
    align-items: center; gap: 12px;
    background: rgba(12,10,8,0.78);
    border: 1px solid var(--border); border-radius: 2px;
    padding: 7px 16px; backdrop-filter: blur(14px);
  }
  .priv-label {
    font-family: 'DM Mono', monospace;
    font-size: 7px; letter-spacing: 0.12em; white-space: nowrap;
    color: var(--text-dim);
  }
  .priv-gradient-bar {
    width: 100px; height: 1px;
    background: linear-gradient(to right, #2a5038, #5a3848);
    opacity: 0.55; flex-shrink: 0;
  }
</style>
</head>
<body>

<div id="graph-area">
  <svg id="svg"></svg>

  <div id="controls">
    <div class="ctrl-group">
      <h4>Show edges</h4>
      <label class="ctrl-row">
        <span class="swatch" style="background:#7a2e1e"></span>
        <input type="checkbox" checked data-edge="required"> required
      </label>
      <label class="ctrl-row">
        <span class="swatch" style="background:#2a5030"></span>
        <input type="checkbox" checked data-edge="enhanced_by"> enhanced_by
      </label>
    </div>
    <div class="ctrl-group">
      <h4>Nodes</h4>
      <button class="toggle-btn active" id="btn-external">Show external patterns</button>
    </div>
    <div class="ctrl-group">
      <h4>Overlays</h4>
      <button class="toggle-btn" id="btn-solar">☀ Solar / cardinal</button>
      <button class="toggle-btn" id="btn-privacy">◐ Public → private</button>
    </div>
  </div>

  <div id="legend">
    <h4>Relationships</h4>
    <div class="legend-row"><div class="legend-line" style="background:#7a2e1e"></div> required</div>
    <div class="legend-row"><div class="legend-line" style="background:#2a5030"></div> enhanced_by</div>
    <div class="legend-row"><div class="legend-line" style="background:transparent; border-top:1px dashed #5a4818"></div> incompatible_with</div>
  </div>

  <!-- Compass rose (solar overlay) -->
  <div id="compass-wrap">
    <h4>Solar / Cardinal</h4>
    <svg viewBox="-46 -46 92 92" width="90" height="90">
      <!-- N spoke -->
      <line x1="0" y1="-8" x2="0" y2="-32" stroke="#4a7090" stroke-width="1.5"/>
      <polygon points="0,-40 -4.5,-30 4.5,-30" fill="#4a7090"/>
      <text x="0" y="-43" text-anchor="middle" fill="#4a7090" font-size="9" font-family="Georgia,serif">N</text>
      <!-- S spoke (thicker — sunlight direction) -->
      <line x1="0" y1="8" x2="0" y2="32" stroke="#907030" stroke-width="2"/>
      <polygon points="0,40 -5.5,30 5.5,30" fill="#907030"/>
      <text x="0" y="46" text-anchor="middle" fill="#907030" font-size="9" font-family="Georgia,serif">S</text>
      <!-- E spoke -->
      <line x1="8" y1="0" x2="30" y2="0" stroke="#7a6530" stroke-width="1.2"/>
      <polygon points="38,0 28,-3.5 28,3.5" fill="#7a6530"/>
      <text x="45" y="3.5" text-anchor="middle" fill="#7a6530" font-size="9" font-family="Georgia,serif">E</text>
      <!-- W spoke -->
      <line x1="-8" y1="0" x2="-30" y2="0" stroke="#7a5040" stroke-width="1.2"/>
      <polygon points="-38,0 -28,-3.5 -28,3.5" fill="#7a5040"/>
      <text x="-45" y="3.5" text-anchor="middle" fill="#7a5040" font-size="9" font-family="Georgia,serif">W</text>
      <!-- Center -->
      <circle cx="0" cy="0" r="5" fill="#100e0b" stroke="rgba(200,185,155,0.2)" stroke-width="1"/>
      <circle cx="0" cy="0" r="2" fill="#66594a"/>
    </svg>
    <div class="compass-legend">
      <span style="color:#907030">S — sunlight</span>
      <span style="color:#4a7090">N — shade</span>
      <span style="color:#7a6530">E — morning</span>
      <span style="color:#7a5040">W — afternoon</span>
    </div>
  </div>

  <!-- Privacy axis bar (privacy overlay) -->
  <div id="privacy-wrap">
    <span class="priv-label" style="color:#3a6850">← public</span>
    <div class="priv-gradient-bar"></div>
    <span class="priv-label" style="color:#6a3870">private →</span>
  </div>

  <div id="hint">scroll to zoom · drag to pan · click node for detail</div>
</div>

<div id="panel" class="hidden">
  <div id="panel-header">
    <div id="panel-num">Pattern</div>
    <div id="panel-name"></div>
    <div id="panel-confidence"></div>
  </div>
  <div id="panel-body"></div>
</div>

<script>
// ─────────────────────────────────────────────
// DATA
// ─────────────────────────────────────────────

const LOADED = {
  76: {
    name: "House for a Small Family",
    confidence: "**",
    problem: "The problem we are trying to solve is that a small family needs several different kinds of spaces, each suited to a different way of being together, yet they must all be connected to form one coherent house.",
    solution: "Arrange the house in the form of a small cluster of pavilions arranged around a courtyard. Each pavilion should be devoted to a single activity and should overlook the courtyard.",
    forces: [
      { name: "family unity vs. individual privacy", type: "social", pole_a: "the need to share meals, gather, and supervise children in common space", pole_b: "the need for adults and children to retreat, work alone, rest, or seek refuge" },
      { name: "functional separation vs. spatial coherence", type: "spatial", pole_a: "each activity benefits from its own distinct, acoustically and visually separated zone", pole_b: "the house must read as one coherent dwelling, not a collection of disconnected buildings" },
      { name: "child supervision vs. child outdoor freedom", type: "social", pole_a: "young children need secure outdoor play space away from adult interior activity", pole_b: "adults need to be able to supervise children without constant physical presence" },
      { name: "generous feeling vs. modest footprint", type: "dimensional", pole_a: "a small family needs spaces that feel generous, well-lit, and comfortable", pole_b: "the house must fit within a modest budget and total floor area of 800–1200 sq ft" },
      { name: "morning routine flow vs. evening leisure flow", type: "temporal", pole_a: "morning use requires rapid sequential access to bathroom, kitchen, and exit routes", pole_b: "evening use requires slow, overlapping, relaxed occupation of common and private areas" },
    ],
    rules: [
      { metric: "Total house area", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "74.3–111.5 m²", source_text: "Total area: 800-1200 square feet" },
      { metric: "Courtyard short side minimum", rule_type: "hard_constraint", mutability: "invariant", value: 4.57, unit: "m", operator: "min", source_text: "minimum 15-20 feet on short side" },
      { metric: "Courtyard enclosure", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "bounded on 3–4 sides by building edges", source_text: "The courtyard is not merely aesthetic but functional" },
      { metric: "Kitchen visual connection to play areas", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "direct sightlines from kitchen to courtyard", source_text: "Parents cook while supervising children" },
      { metric: "Courtyard solar orientation", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "south-facing in northern hemisphere", source_text: "all the rooms which face the courtyard get maximum sun" },
    ],
    failures: [
      { description: "When the courtyard is too small on its short side it cannot accommodate outdoor play or function as a social gathering space; it becomes a gap between buildings rather than a room.", symptom: "Children have no usable outdoor play area; family activity collapses into single interior room" },
      { description: "When pavilions are arranged without enclosing the courtyard on at least three sides, the outdoor space loses enclosure and becomes an open lawn.", symptom: "Outdoor space goes unused; children cannot be passively supervised from kitchen" },
      { description: "When the kitchen has no sightline to play areas, parents must physically leave the kitchen to check on children, interrupting cooking.", symptom: "Children confined indoors; kitchen loses its role as social hub" },
    ],
    color: "#4a7090"
  },
  128: {
    name: "Indoor Sunlight",
    confidence: "***",
    problem: "If the right rooms are facing south, a house is bright and sunny and cheerful; if the wrong rooms are facing south, the house is dark and gloomy.",
    solution: "Place the most important rooms along the south edge of the building, and spread the building out along the east-west axis. Fine tune the arrangement so that the proper rooms are exposed to the south-east and the south-west sun.",
    forces: [
      { name: "solar access vs. programmatic arrangement", type: "spatial", pole_a: "the need to place the most-used rooms where direct sunlight can reach them", pole_b: "the competing organisational logic of the intimacy gradient and functional adjacencies" },
      { name: "thermal comfort in winter vs. overheating in summer", type: "light", pole_a: "the need to admit low winter sun for warmth and brightness", pole_b: "the need to exclude high summer sun to prevent overheating" },
      { name: "interior brightness vs. room depth", type: "light", pole_a: "the desire for sunlit, cheerful interiors with direct sun penetration", pole_b: "the structural tendency to build deep floor plates that leave interior rooms in shadow" },
      { name: "time-of-day use vs. fixed orientation", type: "temporal", pole_a: "different rooms are used at different times of day and benefit from sun at those times", pole_b: "a building has a single fixed orientation that cannot shift to follow the sun" },
    ],
    rules: [
      { metric: "Building axis orientation", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "long axis east-west", source_text: "Note that it is always best to orient the long axis east-west." },
      { metric: "Primary room placement", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "most important rooms along south edge", source_text: "Place the most important rooms along the south edge of the building" },
      { metric: "Common area solar exposure", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "full southern exposure", source_text: "give the common area a full southern exposure" },
      { metric: "Bedroom solar exposure", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "south-east", source_text: "bedrooms south-east" },
      { metric: "Building L:W ratio (temperate)", rule_type: "soft_preference", mutability: "site-adaptive", value: 1.6, unit: "ratio", operator: "ratio", source_text: "temperate (New York) … composite optimum … 1.6" },
    ],
    failures: [
      { description: "When important rooms are placed on the north side, they receive no direct sunlight and remain permanently dark and gloomy.", symptom: "interior feels dark, cold, and cheerless; occupants use artificial light during the day" },
      { description: "When the building is oriented north-south rather than east-west, fewer rooms can access the south edge and the building performs thermally worse.", symptom: "excessive summer overheating and winter heat loss" },
    ],
    color: "#907030"
  },
  129: {
    name: "Common Areas at the Heart",
    confidence: "**",
    problem: "It is perhaps the most basic pattern there is in forming group cohesion.",
    solution: "Create a single common area for every social group. Locate it at the center of gravity of all the spaces the group occupies, and in such a way that the paths which go in and out of the building lie tangent to it.",
    forces: [
      { name: "communal gathering vs. private retreat", type: "social", pole_a: "the need for a shared place where the group can gather, eat, and feel cohesion", pole_b: "the need to reach private rooms without being forced into communal interaction" },
      { name: "accessibility vs. centrality", type: "spatial", pole_a: "the common area must be equally reachable by all members of the group", pole_b: "the common area must not become a dead-end that requires a special detour to reach" },
      { name: "indoor comfort vs. desire to be outside", type: "spatial", pole_a: "the common area provides warmth, food, and seating for communal indoor life", pole_b: "on nice days people long to step outside, sit on grass, or carry on discussions outdoors" },
      { name: "spontaneous encounter vs. deliberate visit", type: "movement", pole_a: "group cohesion is built through casual, unplanned contact as people pass through", pole_b: "if reaching the common area requires purposeful effort, people skip it and isolation grows" },
    ],
    rules: [
      { metric: "Location of common area", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "center of gravity of all spaces the group occupies", source_text: "at the center of gravity of the building complex" },
      { metric: "Path relationship", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "tangent — paths pass alongside but do not dead-end into it", source_text: "the paths which pass it must lie tangent to it" },
      { metric: "Number of common areas per group", rule_type: "hard_constraint", mutability: "invariant", value: 1, unit: "count", operator: "equals", source_text: "Create a single common area for every social group." },
      { metric: "Required components — seating", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "at least some comfortable chairs", source_text: "so people will feel like staying" },
    ],
    failures: [
      { description: "When the common area is placed as a dead-end room, people must make a deliberate detour to reach it and routinely bypass it, so group cohesion never forms.", symptom: "Common room sits empty; members never encounter one another casually" },
      { description: "When the common area is placed off-center, those farther away feel excluded and stop using it.", symptom: "Common area is colonised by the nearest subgroup; distant members form separate gathering spots" },
    ],
    color: "#885030"
  },
  131: {
    name: "The Flow Through Rooms",
    confidence: "**",
    problem: "[Page blocked by content filter — text not available]",
    solution: "As far as possible, avoid the use of corridors and passages. Instead, use public rooms and common rooms as rooms for movement and for gathering. Place the common rooms to form a chain, or loop, so that it becomes possible to walk from room to room.",
    forces: [
      { name: "movement efficiency vs. spatial vitality", type: "movement", pole_a: "the need to move efficiently through a building from room to room", pole_b: "the need for rooms to feel alive, inhabited, and connected rather than sterile" },
      { name: "privacy vs. connection", type: "privacy", pole_a: "the need for private rooms to be sheltered and undisturbed", pole_b: "the need for rooms to feel connected to the larger life of the building" },
      { name: "generous circulation vs. compact plan", type: "spatial", pole_a: "the desire for wide, ample, looping paths that feel generous and inviting", pole_b: "the practical pressure to minimise wasted floor area in a building" },
      { name: "directionality vs. freedom of movement", type: "movement", pole_a: "a linear chain of rooms that creates clear sequential movement", pole_b: "the ability to approach destinations from multiple directions and move freely" },
    ],
    rules: [
      { metric: "Use of corridors and passages", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "avoid entirely wherever possible", source_text: "As far as possible, avoid the use of corridors and passages." },
      { metric: "Common room arrangement", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "chain or loop configuration", source_text: "place the common rooms to form a chain, or loop" },
      { metric: "Private room access", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "open directly off public/common loop rooms", source_text: "private rooms open directly off these public rooms" },
      { metric: "Circulation character", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "wide, ample, generous loop with views of fires and great windows", source_text: "a feeling of great generosity, passing in a wide and ample loop" },
    ],
    failures: [
      { description: "When corridors are used instead of common rooms for circulation, the building feels dead and movement becomes purely functional transit.", symptom: "Corridors go unused except for transit; common rooms lose vitality" },
      { description: "When common rooms are arranged in a dead-end chain without a loop, occupants must retrace their path to exit.", symptom: "Rooms at the end of the chain feel remote and cut off" },
    ],
    color: "#6a4878"
  },
  136: {
    name: "Couple's Realm",
    confidence: "**",
    problem: "The presence of children in a family often destroys the closeness and the special privacy which a man and wife need together.",
    solution: "Make a special part of the house distinct from the common areas and all the children's rooms, where the man and woman of the house can be together in private. Give this place a quick path to the children's rooms, but, at all costs, make it a distinctly separate realm.",
    forces: [
      { name: "couple privacy vs. parental accessibility", type: "privacy", pole_a: "the couple needs a protected, intimate world insulated from children's presence", pole_b: "parents need to remain close enough to respond quickly to children in emergencies" },
      { name: "acoustic privacy vs. open household", type: "spatial", pole_a: "thin shared walls allow children to hear and interrupt the couple's private life", pole_b: "a fully sealed, remote realm would isolate the couple from household life" },
      { name: "couple identity vs. parental role", type: "social", pole_a: "the adult relationship between partners requires its own space, time, and shared private life", pole_b: "parenthood and child-rearing dominate household attention when no separate realm exists" },
      { name: "territorial completeness vs. spatial economy", type: "territorial", pole_a: "the couple's realm must be a complete domain: sitting, sleeping, dressing, bathing", pole_b: "space in a family home is finite and pressure exists to reduce it to merely a bedroom" },
    ],
    rules: [
      { metric: "Separation from children's rooms", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "psychologically far and acoustically buffered", source_text: "at all costs, make it a distinctly separate realm" },
      { metric: "Path to children's rooms", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "quick/direct route must exist", source_text: "Give this place a quick path to the children's rooms" },
      { metric: "Wall acoustic quality", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "walls must provide acoustic privacy; standard thin walls insufficient", source_text: "The walls of the master bedroom are usually too thin" },
      { metric: "Privacy buffer at entrance", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "double door or ante-room at entry", source_text: "it needs some kind of a double door, an ante-room" },
    ],
    failures: [
      { description: "When children can circulate freely through the entire house, they dominate all spaces and no room remains private for the couple.", symptom: "Couple's private life is continually interrupted; parental role permeates all aspects" },
      { description: "When bedroom walls are acoustically thin, the couple is constantly aware of children nearby and cannot achieve intimacy.", symptom: "Private life is permeated by parental awareness; the couple cannot speak privately" },
      { description: "When the couple's realm is reduced to only a bedroom, it fails to function as a complete private world.", symptom: "Conversation, projects, and relaxation have no protected place; couple reverts to shared family spaces" },
    ],
    color: "#7a3828"
  },
  143: {
    name: "Bed Cluster",
    confidence: "*",
    problem: "Every child in the family needs a private place, generally centered around the bed. But in many cultures, perhaps all cultures, young children feel isolated if they sleep alone, if their sleeping area is too private.",
    solution: "[Solution statement not available — page blocked by content filter]",
    forces: [
      { name: "privacy vs. companionship (children's sleep)", type: "social", pole_a: "each child needs a private, individual place centered around their own bed", pole_b: "young children feel isolated and anxious if their sleeping area is too private" },
      { name: "shared space vs. individual territory", type: "territorial", pole_a: "shared bedroom allows companionship but creates conflict over possessions", pole_b: "fully isolated private rooms eliminate conflict but produce loneliness" },
      { name: "individual ownership vs. communal play", type: "social", pole_a: "children are jealous of their toys and need a defensible personal space", pole_b: "children also need shared space for play and social interaction with siblings" },
      { name: "enclosure vs. openness (sleeping alcove)", type: "spatial", pole_a: "the sleeping alcove must feel enclosed and sheltered to provide security", pole_b: "the sleeping area must not be so enclosed that the child feels cut off" },
    ],
    rules: [
      { metric: "Sleeping configuration type", rule_type: "soft_preference", mutability: "invariant", preferred_value: "cluster of individual alcoves around a common playspace — not shared room, not isolated rooms", source_text: "both extremes are bad; some version of the cluster of alcoves is needed" },
      { metric: "Relationship of alcoves to common area", rule_type: "hard_constraint", mutability: "invariant", preferred_value: "individual alcoves must be clustered around and open onto a shared central playspace", source_text: "a kind of configuration in which children have their own, small, private spaces clustered around a common playspace" },
      { metric: "Light provision", rule_type: "soft_preference", mutability: "site-adaptive", preferred_value: "light on two sides of the cluster space", source_text: "Give the entire space LIGHT ON TWO SIDES (159)." },
    ],
    failures: [
      { description: "When all children share one undivided bedroom, they fight constantly over possessions, light, and activities, with no defensible personal territory.", symptom: "Chronic sibling conflict; no child can have quiet or personal space" },
      { description: "When each child has a fully separate private room, young children feel isolated and lonely during sleeping hours.", symptom: "Children feel abandoned or anxious at night" },
      { description: "When sleeping alcoves are not connected to a shared playspace, children lose both the private retreat and the communal connection.", symptom: "The arrangement reverts to either shared-room or isolated-room failure modes" },
    ],
    color: "#38685a"
  }
};

const EXTERNAL_NAMES = {
  61:"Small Public Squares", 75:"The Family", 77:"House for a Couple",
  103:"Forming a Group", 105:"South Facing Outdoors", 106:"Positive Outdoor Space",
  119:"Arcades", 127:"Intimacy Gradient", 130:"Entrance Room",
  132:"Short Passages", 133:"Staircase as a Stage", 134:"Zen View",
  135:"Tapestry of Light and Dark", 137:"Children's Realm", 138:"Sleeping to the East",
  139:"Farmhouse Kitchen", 142:"Sequence of Sitting Spaces", 144:"Bathing Room",
  147:"Communal Eating", 154:"Room Layout", 157:"Home Workshop",
  159:"Light on Two Sides", 161:"Sunny Place", 162:"North Face",
  163:"Outdoor Room", 181:"The Fire", 183:"Workspace Enclosure",
  185:"Sitting Circle", 186:"Communal Sleeping", 187:"Marriage Bed",
  188:"Bed Alcove", 189:"Dressing Room", 191:"Shape of Indoor Space",
  196:"Corner Doors", 198:"Closets Between Rooms", 199:"Sunny Counter",
  203:"Child Caves", 224:"Low Doorway", 236:"Windows Which Open Wide"
};

const RAW_EDGES = [
  // Pattern 76
  { s:76, t:75, r:"required" }, { s:76, t:77, r:"required" },
  { s:76, t:103, r:"required" }, { s:76, t:106, r:"required" },
  // Pattern 128
  { s:128, t:105, r:"required" }, { s:128, t:127, r:"required" },
  { s:128, t:138, r:"enhanced_by" }, { s:128, t:161, r:"enhanced_by" },
  { s:128, t:162, r:"enhanced_by" }, { s:128, t:163, r:"enhanced_by" },
  { s:128, t:199, r:"enhanced_by" }, { s:128, t:236, r:"enhanced_by" },
  // Pattern 129
  { s:129, t:139, r:"required" }, { s:129, t:147, r:"required" },
  { s:129, t:181, r:"required" }, { s:129, t:163, r:"required" },
  { s:129, t:159, r:"enhanced_by" }, { s:129, t:191, r:"enhanced_by" },
  { s:129, t:142, r:"enhanced_by" }, { s:129, t:131, r:"enhanced_by" },
  { s:129, t:132, r:"enhanced_by" },
  // Pattern 131
  { s:131, t:196, r:"required" }, { s:131, t:132, r:"enhanced_by" },
  { s:131, t:130, r:"enhanced_by" }, { s:131, t:133, r:"enhanced_by" },
  { s:131, t:159, r:"enhanced_by" },
  // Pattern 136
  { s:136, t:127, r:"required" }, { s:136, t:185, r:"required" },
  { s:136, t:187, r:"required" }, { s:136, t:76, r:"enhanced_by" },
  { s:136, t:138, r:"enhanced_by" }, { s:136, t:144, r:"enhanced_by" },
  { s:136, t:159, r:"enhanced_by" }, { s:136, t:189, r:"enhanced_by" },
  { s:136, t:191, r:"enhanced_by" },
  // Pattern 143
  { s:143, t:136, r:"required" }, { s:143, t:137, r:"required" },
  { s:143, t:138, r:"required" }, { s:143, t:188, r:"required" },
  { s:143, t:159, r:"required" }, { s:143, t:191, r:"required" },
  { s:143, t:186, r:"enhanced_by" }, { s:143, t:189, r:"enhanced_by" },
  { s:143, t:203, r:"enhanced_by" },
];

// ─────────────────────────────────────────────
// TENSION NOTES
// Why each required relationship matters — drawn verbatim from the
// adjacency_rules notes in the knowledge JSON files. Keyed "{source}-{target}".
// ─────────────────────────────────────────────

const TENSION_NOTES = {
  "76-75":   "Establishes the social unit and its needs — 'The Family' pattern must be resolved before this one can be properly applied.",
  "76-77":   "Defines the gradient from public to private space within the house; the pavilion arrangement must implement these gradients.",
  "76-103":  "The pavilion cluster is a direct instance of forming a group of buildings; its courtyard geometry must follow Pattern 103 principles.",
  "76-106":  "The courtyard only functions as an outdoor room when it forms positive space bounded on three or more sides by building edges.",
  "128-105": "Pattern 105 establishes the building's southern orientation as prerequisite; Pattern 128 refines the internal room arrangement within that framework.",
  "128-127": "The intimacy gradient determines the distribution of public and private rooms; indoor sunlight assigns solar exposure within that gradient.",
  "129-139": "The farmhouse kitchen is the primary common room that anchors the heart of the group.",
  "129-147": "Communal eating is the central activity the common area exists to support — the space is organised around shared meals.",
  "129-181": "The fire provides the social and thermal heart around which the common area is organised.",
  "129-163": "The outdoor room extends the common area outward; paths pass through both indoor and outdoor common space.",
  "131-196": "Corner doors are required to make rooms flow into each other — without them, rooms become dead-ends with single-entry walls.",
  "136-127": "The intimacy gradient establishes the position of the couple's realm within the overall pattern of private to public space.",
  "136-185": "The sitting circle is the key element of the couple's daytime realm — without it, the realm collapses to merely a sleeping room.",
  "136-187": "The marriage bed is the defining element of the couple's private domain.",
  "143-136": "The children's bed cluster is positioned within and relative to the couple's realm — not as an independent zone.",
  "143-137": "The children's realm must be established before the bed cluster can be properly sited within it.",
  "143-138": "Morning sun marks the transition from sleep to waking; sleeping alcoves of the bed cluster require eastern exposure.",
  "143-188": "Bed alcoves are the physical implementation of the sleeping component of the cluster.",
  "143-159": "Light on two sides is required for the shared playspace of the cluster to feel alive and connected.",
  "143-191": "The shape of indoor space governs how the alcoves and shared playspace relate to each other.",
};

// ─────────────────────────────────────────────
// ANNOTATIONS
// The designer's responses to tension provocations.
// Persisted in localStorage, keyed "{source}-{target}".
// ─────────────────────────────────────────────

let ANNOTATIONS = {};
try { ANNOTATIONS = JSON.parse(localStorage.getItem("pattern-annotations") || "{}"); } catch(e) {}

function saveAnnotation(key, value) {
  if (value) ANNOTATIONS[key] = value;
  else delete ANNOTATIONS[key];
  localStorage.setItem("pattern-annotations", JSON.stringify(ANNOTATIONS));
}

// Returns { unmet: [...], acknowledged: [...], satisfied: [...] }
// unmet      — required pattern missing, no note recorded
// acknowledged — required pattern missing, but designer has recorded a note
// satisfied  — required pattern is loaded in the graph
function computeTensions(patternId) {
  const requiredEdges = RAW_EDGES.filter(e => e.s === patternId && e.r === "required");
  const out = { unmet: [], acknowledged: [], satisfied: [] };
  for (const edge of requiredEdges) {
    if (LOADED[edge.t]) {
      out.satisfied.push(edge.t);
    } else {
      const key = `${patternId}-${edge.t}`;
      const entry = {
        target: edge.t,
        name: EXTERNAL_NAMES[edge.t] || `Pattern ${edge.t}`,
        note: TENSION_NOTES[key] || "",
        annotation: ANNOTATIONS[key] || "",
        key,
      };
      if (ANNOTATIONS[key]) out.acknowledged.push(entry);
      else out.unmet.push(entry);
    }
  }
  return out;
}

// ─────────────────────────────────────────────
// FORCE TYPE COLOURS
// ─────────────────────────────────────────────
const FORCE_COLORS = {
  social:      { bg:"#0e1218", text:"#6080a0", border:"#1a2530" },
  spatial:     { bg:"#120e18", text:"#8868a8", border:"#22183a" },
  dimensional: { bg:"#0e1810", text:"#507858", border:"#182a1a" },
  light:       { bg:"#181408", text:"#988040", border:"#302810" },
  movement:    { bg:"#180e08", text:"#986040", border:"#302010" },
  privacy:     { bg:"#160810", text:"#986088", border:"#280a20" },
  territorial: { bg:"#160808", text:"#985858", border:"#280808" },
  temporal:    { bg:"#0e0e0e", text:"#686868", border:"#1e1e1e" },
};

// ─────────────────────────────────────────────
// ENVIRONMENTAL DATA
// ─────────────────────────────────────────────

// Solar orientation preference per pattern (compass bearing: 0=N, 90=E, 180=S, 270=W)
// strength: 0–1, how strongly this pattern asserts its solar preference in collective negotiation
const SOLAR_PREF = {
  76:  { bearing: 180, strength: 0.60, label: "S" },  // courtyard solar orientation: important but secondary
  128: { bearing: 180, strength: 1.00, label: "S" },  // Indoor Sunlight — this IS the solar pattern
  136: { bearing:  90, strength: 0.40, label: "E" },  // enhanced_by Sleeping to the East (138)
  143: { bearing:  90, strength: 0.50, label: "E" },  // requires Sleeping to the East (138)
};

// Public → private spectrum: 0 = very public, 1 = very private
const PRIVACY_SCORE = {
  76:  0.45,  // House for a Small Family — balanced public/private
  128: 0.25,  // Indoor Sunlight — about shared, communal room orientation
  129: 0.08,  // Common Areas at the Heart — the public heart of a group
  131: 0.18,  // Flow Through Rooms — public circulation loop
  136: 0.92,  // Couple's Realm — maximally private
  143: 0.78,  // Bed Cluster — private sleeping domain
};

// ─────────────────────────────────────────────
// ENVIRONMENTAL HELPERS
// ─────────────────────────────────────────────

// Filled sector path from center, pointing at 'bearing' degrees
function solarArcPath(bearing) {
  const R = 47, spread = 42;
  const a1 = (bearing - spread - 90) * Math.PI / 180;
  const a2 = (bearing + spread - 90) * Math.PI / 180;
  const x1 = +(Math.cos(a1) * R).toFixed(2), y1 = +(Math.sin(a1) * R).toFixed(2);
  const x2 = +(Math.cos(a2) * R).toFixed(2), y2 = +(Math.sin(a2) * R).toFixed(2);
  return `M0,0 L${x1},${y1} A${R},${R} 0 0,1 ${x2},${y2} Z`;
}

function solarArcColor(bearing) {
  if (bearing === 180) return "#907030"; // south — warm amber
  if (bearing ===   0) return "#4a7090"; // north — slate blue
  if (bearing ===  90) return "#7a6530"; // east — morning
  if (bearing === 270) return "#7a5040"; // west — afternoon
  return "#66594a";
}

// Interpolate muted sage (#3a6850) → muted mauve (#6a3870) for public→private
function privacyColor(score) {
  const r = Math.round( 58 + (106 -  58) * score);
  const g = Math.round(104 + ( 56 - 104) * score);
  const b = Math.round( 80 + (112 -  80) * score);
  return `rgb(${r},${g},${b})`;
}

// ─────────────────────────────────────────────
// ENVIRONMENTAL PHYSICS — FORCE FACTORIES
// Each factory builds a named D3 force for the current overlay state.
// Re-registering a force on the simulation triggers D3's initialize(),
// which re-evaluates and caches strength per node — this is how we
// dynamically switch forces on/off without a full re-render.
// ─────────────────────────────────────────────

function makeSolarForceX(cx, w) {
  // East/west component of solar preference
  return d3.forceX(d => {
    if (d.type !== "loaded") return cx;
    const p = SOLAR_PREF[d.id];
    if (!p) return cx;
    if (p.bearing === 90)  return cx + w * 0.30;  // east
    if (p.bearing === 270) return cx - w * 0.30;  // west
    return cx; // south/north — no east/west pull
  }).strength(d => {
    if (!showSolar || d.type !== "loaded") return 0;
    const p = SOLAR_PREF[d.id];
    if (!p) return 0;
    return (p.bearing === 90 || p.bearing === 270) ? p.strength * 0.10 : 0;
  });
}

function makeSolarForceY(cy, h) {
  // North/south component of solar preference
  return d3.forceY(d => {
    if (d.type !== "loaded") return cy;
    const p = SOLAR_PREF[d.id];
    if (!p) return cy;
    if (p.bearing === 180) return cy + h * 0.28;  // south — toward sunlight
    if (p.bearing ===   0) return cy - h * 0.28;  // north — toward shade
    return cy; // east/west — no north/south pull
  }).strength(d => {
    if (!showSolar || d.type !== "loaded") return 0;
    const p = SOLAR_PREF[d.id];
    if (!p) return 0;
    return (p.bearing === 0 || p.bearing === 180) ? p.strength * 0.10 : 0;
  });
}

function makePrivacyForceX(cx, w) {
  // Public (left) ←→ Private (right) horizontal pull
  // Strength is proportional to how extreme the score is — balanced
  // patterns (76, score≈0.5) barely move; strongly public/private ones
  // pull hard. This means the negotiation is loudest at the extremes.
  return d3.forceX(d => {
    if (d.type !== "loaded") return cx;
    const s = PRIVACY_SCORE[d.id];
    if (s === undefined) return cx;
    return cx + (s - 0.5) * w * 0.58;
  }).strength(d => {
    if (!showPrivacy || d.type !== "loaded") return 0;
    const s = PRIVACY_SCORE[d.id];
    if (s === undefined) return 0;
    return Math.abs(s - 0.5) * 2 * 0.09; // 0 at center, ~0.09 at extremes
  });
}

// ─────────────────────────────────────────────
// BUILD GRAPH DATA
// ─────────────────────────────────────────────

function buildGraph(showExternal) {
  const loadedIds = new Set(Object.keys(LOADED).map(Number));
  const usedExternal = new Set();

  if (showExternal) {
    RAW_EDGES.forEach(e => {
      if (!loadedIds.has(e.t)) usedExternal.add(e.t);
    });
  }

  const nodes = [];
  Object.entries(LOADED).forEach(([id, d]) => {
    nodes.push({ id: +id, type: "loaded", name: d.name, color: d.color });
  });
  usedExternal.forEach(id => {
    nodes.push({ id, type: "external", name: EXTERNAL_NAMES[id] || "Pattern " + id });
  });

  const nodeIds = new Set(nodes.map(n => n.id));
  const links = RAW_EDGES
    .filter(e => nodeIds.has(e.s) && nodeIds.has(e.t))
    .map(e => ({ source: e.s, target: e.t, rel: e.r }));

  return { nodes, links };
}

// ─────────────────────────────────────────────
// VIZ SETUP
// ─────────────────────────────────────────────

let showExternal = true;
let edgeFilter   = { required: true, enhanced_by: true };
let activeNode   = null;
let showSolar    = false;
let showPrivacy  = false;

const svg       = d3.select("#svg");
const defs      = svg.append("defs");

// ── Gradient defs ──

// Solar: warm amber at bottom (south), cool blue at top (north)
const solarGrad = defs.append("linearGradient")
  .attr("id", "grad-solar")
  .attr("x1", "0%").attr("y1", "100%")
  .attr("x2", "0%").attr("y2", "0%");
solarGrad.append("stop").attr("offset",  "0%").attr("stop-color", "#907030").attr("stop-opacity", 0.06);
solarGrad.append("stop").attr("offset", "48%").attr("stop-color", "#0c0a08").attr("stop-opacity", 0);
solarGrad.append("stop").attr("offset","100%").attr("stop-color", "#4a7090").attr("stop-opacity", 0.04);

// Privacy: green on left (public), purple on right (private)
const privGrad = defs.append("linearGradient")
  .attr("id", "grad-privacy")
  .attr("x1", "0%").attr("y1", "0%")
  .attr("x2","100%").attr("y2", "0%");
privGrad.append("stop").attr("offset",  "0%").attr("stop-color", "#3a6850").attr("stop-opacity", 0.06);
privGrad.append("stop").attr("offset", "48%").attr("stop-color", "#0c0a08").attr("stop-opacity", 0);
privGrad.append("stop").attr("offset","100%").attr("stop-color", "#6a3870").attr("stop-opacity", 0.06);

// ── Fixed background overlay rects (rendered before zoom container) ──

svg.append("rect")
  .attr("id", "solar-bg")
  .attr("width", "100%").attr("height", "100%")
  .attr("fill", "url(#grad-solar)")
  .attr("pointer-events", "none")
  .attr("display", "none");

svg.append("rect")
  .attr("id", "privacy-bg")
  .attr("width", "100%").attr("height", "100%")
  .attr("fill", "url(#grad-privacy)")
  .attr("pointer-events", "none")
  .attr("display", "none");

// ── Zoom container (on top of background overlays) ──
const container = svg.append("g");

svg.call(d3.zoom().scaleExtent([0.15, 3]).on("zoom", e => {
  container.attr("transform", e.transform);
}));

// ── Arrow markers ──
function addMarker(id, color) {
  defs.append("marker")
    .attr("id", id)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 22)
    .attr("refY", 0)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", color)
    .attr("class", "link-arrow");
}
addMarker("arrow-required",        "#7a2e1e");
addMarker("arrow-enhanced_by",     "#2a5030");
addMarker("arrow-ext-required",    "#4a1e14");
addMarker("arrow-ext-enhanced_by", "#1a3820");

const markerFor = (rel, isInternal) => `url(#arrow-${isInternal ? "" : "ext-"}${rel})`;

let linkG, nodeG, simulation;

// ─────────────────────────────────────────────
// RENDER
// ─────────────────────────────────────────────

function render() {
  const data = buildGraph(showExternal);
  const filteredLinks = data.links.filter(l => edgeFilter[l.rel]);

  container.selectAll("*").remove();

  const gw = document.getElementById("graph-area").clientWidth;
  const gh = document.getElementById("graph-area").clientHeight;
  const cx = gw / 2, cy = gh / 2;

  simulation = d3.forceSimulation(data.nodes)
    .force("link", d3.forceLink(filteredLinks).id(d => d.id).distance(d => {
      const sLoaded = LOADED[d.source.id || d.source];
      const tLoaded = LOADED[d.target.id || d.target];
      return (sLoaded && tLoaded) ? 180 : 110;
    }).strength(0.6))
    .force("charge", d3.forceManyBody().strength(d => d.type === "loaded" ? -500 : -100))
    .force("center", d3.forceCenter(cx, cy).strength(showSolar || showPrivacy ? 0.02 : 0.08))
    .force("collide", d3.forceCollide().radius(d => d.type === "loaded" ? 42 : 20))
    // Environmental forces — active only when overlay is on; re-registered in updateOverlays()
    .force("solar-x",   makeSolarForceX(cx, gw))
    .force("solar-y",   makeSolarForceY(cy, gh))
    .force("privacy-x", makePrivacyForceX(cx, gw));

  // Links
  linkG = container.append("g").selectAll("line")
    .data(filteredLinks)
    .join("line")
    .attr("class", d => `link ${d.rel}`)
    .attr("stroke-dasharray", d => d.rel === "incompatible" ? "5,4" : null)
    .attr("marker-end", d => {
      const sLoaded = !!LOADED[d.source.id || d.source];
      const tLoaded = !!LOADED[d.target.id || d.target];
      return markerFor(d.rel, sLoaded && tLoaded);
    });

  // Nodes
  nodeG = container.append("g").selectAll("g")
    .data(data.nodes, d => d.id)
    .join("g")
    .attr("class", d => `node-${d.type}`)
    .call(d3.drag()
      .on("start", (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
      .on("drag",  (e, d) => { d.fx = e.x; d.fy = e.y; })
      .on("end",   (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
    )
    .on("click", (e, d) => {
      e.stopPropagation();
      if (d.type === "loaded") selectPattern(d.id);
    });

  // ── Loaded nodes ──

  // 1. Solar arc (behind circle — rendered first)
  nodeG.filter(d => d.type === "loaded").append("path")
    .attr("class", "solar-arc")
    .attr("d", d => SOLAR_PREF[d.id] ? solarArcPath(SOLAR_PREF[d.id].bearing) : "")
    .attr("fill", d => SOLAR_PREF[d.id] ? solarArcColor(SOLAR_PREF[d.id].bearing) : "none")
    .attr("fill-opacity", 0.18)
    .attr("pointer-events", "none")
    .attr("display", "none"); // hidden until overlay activated

  // 2. Strain ring — slow/fast rotating dashed ring, colour and speed scale with
  //    the number of unaddressed required-relationship gaps for this pattern.
  //    Updated by updateStrainRings() after render and after each annotation change.
  nodeG.filter(d => d.type === "loaded").append("circle")
    .attr("class", "strain-ring strain-none")
    .attr("r", 38);

  // 3. Circle
  nodeG.filter(d => d.type === "loaded").append("circle")
    .attr("r", 28)
    .attr("fill", d => d.color + "1a")
    .attr("stroke", d => d.color);

  // 3. Privacy band (below circle)
  nodeG.filter(d => d.type === "loaded").append("rect")
    .attr("class", "privacy-band")
    .attr("x", -10).attr("y", 33)
    .attr("width", 20).attr("height", 2)
    .attr("rx", 2)
    .attr("fill", d => privacyColor(PRIVACY_SCORE[d.id] !== undefined ? PRIVACY_SCORE[d.id] : 0.5))
    .attr("pointer-events", "none")
    .attr("display", "none"); // hidden until overlay activated

  // 4. Label (number + name)
  const loadedLabel = nodeG.filter(d => d.type === "loaded").append("text").attr("class", "label-loaded");
  loadedLabel.append("tspan").attr("class", "num").attr("x", 0).attr("dy", "-0.3em").text(d => d.id);
  loadedLabel.append("tspan").attr("x", 0).attr("dy", "1.2em").text(d => {
    const words = d.name.split(" ");
    return words.length > 3 ? words.slice(0, 2).join(" ") + "…" : d.name;
  });

  // ── External nodes ──
  nodeG.filter(d => d.type === "external").append("circle")
    .attr("r", 12)
    .attr("fill", "#100e0b")
    .attr("stroke", "rgba(200,185,155,0.18)");

  nodeG.filter(d => d.type === "external").append("text")
    .attr("class", "label-external")
    .attr("dy", "0.32em")
    .text(d => d.id);

  // Tick
  simulation.on("tick", () => {
    linkG
      .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    nodeG.attr("transform", d => `translate(${d.x},${d.y})`);
  });

  if (activeNode) highlightNode(activeNode);

  // Apply current overlay state to freshly rendered elements
  updateOverlays();
  updateStrainRings();
}

// ─────────────────────────────────────────────
// STRAIN RINGS
// ─────────────────────────────────────────────

function updateStrainRings() {
  if (!nodeG) return;
  nodeG.filter(d => d.type === "loaded").select(".strain-ring")
    .attr("class", d => {
      const t = computeTensions(d.id);
      const n = t.unmet.length;
      if (n === 0) return "strain-ring strain-none";
      if (n <= 2)  return "strain-ring strain-low";
      if (n <= 4)  return "strain-ring strain-mid";
      return "strain-ring strain-high";
    });
}

// ─────────────────────────────────────────────
// OVERLAYS
// ─────────────────────────────────────────────

function updateOverlays() {
  // ── Visual elements ──
  d3.select("#solar-bg").attr("display",   showSolar   ? null : "none");
  d3.select("#privacy-bg").attr("display", showPrivacy ? null : "none");
  document.getElementById("compass-wrap").style.display  = showSolar   ? "block" : "none";
  document.getElementById("privacy-wrap").style.display  = showPrivacy ? "flex"  : "none";
  container.selectAll(".solar-arc")    .attr("display", showSolar   ? null : "none");
  container.selectAll(".privacy-band") .attr("display", showPrivacy ? null : "none");

  // ── Physics ──
  // Re-register the environmental forces so D3 re-initialises strength
  // caches with the current showSolar / showPrivacy state, then re-energise
  // the simulation so patterns negotiate their new collective arrangement.
  if (simulation) {
    const gw = document.getElementById("graph-area").clientWidth;
    const gh = document.getElementById("graph-area").clientHeight;
    const cx = gw / 2, cy = gh / 2;

    simulation
      .force("solar-x",   makeSolarForceX(cx, gw))
      .force("solar-y",   makeSolarForceY(cy, gh))
      .force("privacy-x", makePrivacyForceX(cx, gw))
      .force("center",    d3.forceCenter(cx, cy).strength(showSolar || showPrivacy ? 0.02 : 0.08));

    // alpha(0.6) gives the simulation enough energy to fully re-settle
    simulation.alpha(0.6).restart();
  }
}

// ─────────────────────────────────────────────
// INTERACTION
// ─────────────────────────────────────────────

svg.on("click", () => {
  activeNode = null;
  container.selectAll(".node-loaded").classed("active", false);
  document.getElementById("panel").classList.add("hidden");
});

function highlightNode(id) {
  container.selectAll(".node-loaded").classed("active", d => d.id === id);
}

function selectPattern(id) {
  activeNode = id;
  highlightNode(id);
  fillPanel(id);
  document.getElementById("panel").classList.remove("hidden");
}

function fillPanel(id) {
  const p = LOADED[id];
  document.getElementById("panel-num").textContent = `Pattern ${id}`;
  document.getElementById("panel-name").textContent = p.name;
  document.getElementById("panel-confidence").innerHTML =
    `Confidence <span style="color:${confidenceColor(p.confidence)}">${p.confidence}</span>`;

  const body = document.getElementById("panel-body");
  body.innerHTML = "";

  // ── Tensions ──
  const tensions = computeTensions(id);
  const hasAny = tensions.unmet.length + tensions.acknowledged.length > 0;
  if (hasAny) {
    let titleParts = [];
    if (tensions.unmet.length)       titleParts.push(`${tensions.unmet.length} open`);
    if (tensions.acknowledged.length) titleParts.push(`${tensions.acknowledged.length} noted`);

    const wrap = document.createElement("div");
    wrap.className = "tension-section";
    wrap.innerHTML = `<div class="tension-section-title">Tensions — ${titleParts.join(", ")}</div>`;

    const buildItem = (t, isAcked) => {
      const div = document.createElement("div");
      div.className = "tension-item" + (isAcked ? " tension-acked" : "");
      if (isAcked) {
        div.innerHTML = `
          <div class="tension-header">
            <span class="tension-badge tension-noted">noted</span>
            <span class="tension-target-name">→ ${t.target}: ${esc(t.name)}</span>
          </div>
          <div class="tension-ann-display">${esc(t.annotation)}</div>
          <button class="tension-edit-btn">revise note</button>`;
        div.querySelector(".tension-edit-btn").addEventListener("click", () => {
          saveAnnotation(t.key, "");
          fillPanel(id);
          updateStrainRings();
        });
      } else {
        div.innerHTML = `
          <div class="tension-header">
            <span class="tension-badge tension-open">open</span>
            <span class="tension-target-name">→ ${t.target}: ${esc(t.name)}</span>
          </div>
          ${t.note ? `<div class="tension-note">${esc(t.note)}</div>` : ""}
          <div class="tension-annotation-wrap">
            <textarea class="tension-annotation"
              placeholder="How does your scheme address this — or is this a deliberate choice?">${esc(t.annotation)}</textarea>
            <button class="tension-save-btn">Save note</button>
          </div>`;
        div.querySelector(".tension-save-btn").addEventListener("click", () => {
          const val = div.querySelector(".tension-annotation").value.trim();
          if (val) {
            saveAnnotation(t.key, val);
            fillPanel(id);
            updateStrainRings();
          }
        });
      }
      return div;
    };

    tensions.unmet.forEach(t       => wrap.appendChild(buildItem(t, false)));
    tensions.acknowledged.forEach(t => wrap.appendChild(buildItem(t, true)));
    body.appendChild(wrap);
  }

  // Verbatim
  body.appendChild(section("Verbatim", `
    <div class="verbatim-block">
      <div class="verbatim-label">Problem</div>
      ${esc(p.problem)}
    </div>
    <div class="verbatim-block">
      <div class="verbatim-label">Solution (Therefore:)</div>
      ${esc(p.solution)}
    </div>
  `));

  // Forces
  const forcesHtml = p.forces.map(f => {
    const fc = FORCE_COLORS[f.type] || FORCE_COLORS.social;
    return `
      <div class="force-card">
        <div class="force-header">
          <span class="force-type-badge" style="background:${fc.bg};color:${fc.text};border:1px solid ${fc.border}">${f.type}</span>
          <span class="force-name">${esc(f.name)}</span>
        </div>
        <div class="poles">
          <div class="pole pole-a">${esc(f.pole_a)}</div>
          <div class="pole pole-b">${esc(f.pole_b)}</div>
        </div>
      </div>`;
  }).join("");
  body.appendChild(section(`Forces (${p.forces.length})`, forcesHtml));

  // Rules
  const rulesHtml = p.rules.map(r => {
    let valueStr = "";
    if (r.value !== undefined) {
      valueStr = `${r.operator ? r.operator + " " : ""}${r.value}${r.unit ? " " + r.unit : ""}`;
    } else if (r.preferred_value) {
      valueStr = r.preferred_value;
    }
    return `
      <div class="rule-row">
        <div class="rule-header">
          <span class="rule-badge ${r.rule_type === "hard_constraint" ? "hard" : "soft"}">${r.rule_type === "hard_constraint" ? "hard" : "soft"}</span>
          <span class="rule-badge ${r.mutability === "invariant" ? "inv" : "adp"}">${r.mutability === "invariant" ? "invariant" : "adaptive"}</span>
          <span class="rule-metric">${esc(r.metric)}</span>
        </div>
        ${valueStr ? `<div class="rule-value">${esc(valueStr)}</div>` : ""}
        ${r.source_text ? `<div class="rule-source">"${esc(r.source_text)}"</div>` : ""}
      </div>`;
  }).join("");
  body.appendChild(section(`Typed Rules (${p.rules.length})`, rulesHtml));

  // Failures
  const failHtml = p.failures.map(f => `
    <div class="failure-row">
      <div class="failure-desc">${esc(f.description)}</div>
      <div class="failure-sym">${esc(f.symptom)}</div>
    </div>`).join("");
  body.appendChild(section(`Failure Modes (${p.failures.length})`, failHtml));
}

function section(title, html) {
  const div = document.createElement("div");
  div.className = "section";
  div.innerHTML = `<div class="section-title">${title}</div>${html}`;
  return div;
}

function esc(s) {
  if (!s) return "";
  return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

function confidenceColor(c) {
  return { "*":"#8a4030", "**":"#907030", "***":"#3a6030" }[c] || "#4a4038";
}

// ─────────────────────────────────────────────
// CONTROLS
// ─────────────────────────────────────────────

document.querySelectorAll("[data-edge]").forEach(cb => {
  cb.addEventListener("change", () => {
    edgeFilter[cb.dataset.edge] = cb.checked;
    render();
  });
});

document.getElementById("btn-external").addEventListener("click", function() {
  showExternal = !showExternal;
  this.classList.toggle("active", showExternal);
  this.textContent = showExternal ? "Show external patterns" : "Hide external patterns";
  render();
});

document.getElementById("btn-solar").addEventListener("click", function() {
  showSolar = !showSolar;
  this.classList.toggle("active", showSolar);
  this.classList.toggle("solar-on", showSolar);
  updateOverlays();
});

document.getElementById("btn-privacy").addEventListener("click", function() {
  showPrivacy = !showPrivacy;
  this.classList.toggle("active", showPrivacy);
  this.classList.toggle("priv-on", showPrivacy);
  updateOverlays();
});

// ─────────────────────────────────────────────
// INIT
// ─────────────────────────────────────────────
render();
</script>
</body>
</html>
